<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h2><code>do</code>/<code>on</code> Notation</h2>
    <p>In <a href="https://github.com/tobybenjaminclark/mpir">MPIR</a>, the <em>Do/On (Doon!) Notation</em> facilitates <u>conditional actions</u> based on <strong>pattern matching the return value of a function</strong>, eliminating the need for an intermediate variable. The syntax involves using the <code>do</code> keyword for the function call and the <code>on</code> keyword followed by a literal to match the result.
    This is called using the <code>do</code> and <code>on</code> keywords.</p>
    <ol>
        <li><code>do</code> <strong><code>function</code></strong> is used to call the desired function.</li>
        <li><code>on</code> <strong><code>literal</code></strong> <code>→</code> is used to match the result against a literal.</li>
    </ol>
    <p>The following is an example of a <code>do</code>/<code>on</code> implementation. If the returned value of the <code>function call</code> is <code>True</code>, then 'result was True' is shown to the console. If the returned value of the <code>function call</code> is <code>False</code>, then 'result was False' is shown.</p>
    <pre><code>do function call
on True → show "result was True"
on False → show "result was False"
</code></pre>
    <p><a href="https://github.com/tobybenjaminclark/mpir">MPIR</a> offers the <code>do</code>/<code>on</code> syntax to encourage the implementation and catching of maintainable error codes in functions. This can be seen as a streamlined alternative to the following code, which uses traditional <code>if</code>/<code>else</code> syntax.</p>
    <pre><code>type variable = function call
if variable == True: show "result was True"
if variable == True: show "result was False"
</code></pre>

    <h2><code>funcdef</code> Notation</h2>
    <p>In <a href="https://github.com/tobybenjaminclark/mpir">MPIR</a>, the <code>typedef</code> keyword is used to define a new type or type alias. Any type declaration must have a base type, which can be viewed as a <strong>building block for a more complex type</strong>. One of MPIR's founding principles is <em>type refinement</em>, which won't be covered in this section but will be applied using a <code>typedef</code>.</p>
    <h3>Function Declarations/Headers</h3>
    <p>To define a <em>function header</em>, which defines the general use of a function, the following syntax can be used. The name of the function and its parameters are defined, with types defined afterward, following the sequential ordering of the previous declaration.</p>
    <pre><code>funcdef function name parameter/s :: input type/s → output type\s
...
</code></pre>
    <h3>Function Definitions</h3>
    <p>To define a <em>function definition</em>, which is what the function actually does, there are a variety of approaches to be used. <a href="https://github.com/tobybenjaminclark/mpir">MPIR</a> facilitates the definition of a function's body through the following techniques:</p>
    <ul>
        <li>Pattern Matching</li>
        <li>Imperative Definition</li>
    </ul>
    <h4>Function Definition using <u>Pattern Matching</u></h4>
    <p>To define a function's body using <strong>pattern matching</strong>, the following syntax can be used.</p>
    <pre><code>...
funcdef function name parameters = returned expression
</code></pre>
    <p>For example,</p>
    <pre><code>funcdef multiply x y :: Int, Int → Int
funcdef multiply 0, 0 = 0
funcdef multiply x, y = x * y
</code></pre>

    <h2><code>typedef</code> Notation</h2>
    <p>In <a href="https://github.com/tobybenjaminclark/mpir">MPIR</a>, the <code>typedef</code> keyword is used to define a new type or type alias. Any type declaration must have a base type, which can be viewed as a <strong>building block for a more complex type</strong>. One of MPIR's founding principles is <em>type refinement</em>, which won't be covered in this section but will be applied using a <code>typedef</code>.</p>
    <h3>Type Alias Declarations &amp; Definitions</h3>
    <p>To define a <em>type alias</em>, which can be seen as <strong>declaring a new name for an existing type</strong>, the following syntax can be used.</p>
    <pre><code>typedef type name parameter/s :: base type
typedef parameter : base type
</code></pre>
    <p>This is an example declaration of a new type <code>Integer</code>, which acts as an <strong>alias</strong> to the primitive/base type <code>Int</code>, with no additional refinement.</p>
    <pre><code>typedef Integer i :: Int
typedef i : Int
</code></pre>
    <h3>Type Refinement Declarations &amp; Definitions</h3>
    <p>To define a <em>type refinement</em>, which can be seen as <strong>declaring a new type as a set of constraints on another type</strong>, the optional refinement clause of the <code>typedef</code> declaration can be used. This can be seen in the following syntax.</p>
    <pre><code>typedef type name parameter/s :: base type
typedef parameter : base type { refinement }
</code></pre>
    <p>This is an example declaration of a new type <code>PositiveInteger</code>, which uses the base type <code>Int</code> with a <strong>refinement</strong> that all values of <code>i</code> must be greater than zero, hence all values of <code>i</code> must be positive.</p>
    <p>Refinements on types are expressed using propositional/predicate notation. More about this can be seen under the type refinement section. Type Refinement is a powerful tool
